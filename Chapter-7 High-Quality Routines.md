# 第七章 高质量的子程序



## 什么是高质量的子程序？

什么是高质量的子程序？回答这个问题最简单的办法是，来看看什么东西不是高质量的子程序。这里有一个低质量子程序的例子，书中提示至少可以从中发现 10 处不同的问题。

```cpp
// C++ Example of a Low-Quality Routine
void HandleStuff(CORP_DATA & inputRec, int crntQtr, EMP_DATA empRec,
   double & estimRevenue, double ytdRevenue, int screenX, int screenY,
   COLOR_TYPE & newColor, COLOR_TYPE & prevColor, StatusType &status,
   int expenseType)
{
int i;
for (i = 0; i < 100; i++) {
   inputRec.revenue[i] = 0;
   inputRec.expense[i] = corpExpense[ crntQtr ][ i ];
   }
UpdateCorpDatabase(empRec);
estimRevenue = ytdRevenue * 4.0 / (double) crntQtr;
newColor = prevColor;
status = SUCCESS;
if (expenseType == 1) {
     for (i = 0; i < 12; i++)
           profit[i] = revenue[i] - expense.type1[i];
     }
else if (expenseType == 2) {
          profit[i] = revenue[i] - expense.type2[i];
          }
else if (expenseType == 3)
          profit[i] = revenue[i] - expense.type3[i];
          }
```

这个程序有何不妥？这里有一份清单：
1. 子程序有一个很差劲的名字。`HandleStuff()` 几乎没有什么信息量。
2. 没有文档（注：或者说注释？有关文档的话题见第32章“自说明代码”）。
3. 布局不好。缩进等几乎没有给出任何逻辑组织的提示，`expenseType == 2` 和 `expenseType == 3` 处存在不同的布局风格。
4. 输入变量 `inputRec` 被修改了（若为输入变量，其值就不应该被修改；若就是要被修改的，就不应命名为`inputRec`）
5. 读写了全局变量`（corpExpense）`。应该更直接地与其他子程序通信，而不是去读写全局变量。
6. 子程序应该有单一而明确的目的。这个子程序初始化了一些变量，向数据库写入数据……这些事情看不出有什么联系。
7. 没有防范错误数据（bad data）。`crntQtr` 为0时将导致除零错误。
8. 使用了神秘数字。如100,  4.0，12 ……
9. 参数个数太多（合理参数个数的上限为7个左右），参数的排布方式也难以理解。
10. 参数顺序混乱且未经注释。

“创建一个子程序可以有很多合理的原因，但完成它的方式却有对错之分。” Steve 在上大学的时候曾认为创建子程序的主要原因不过是为了避免重复代码，教材上也那样写（注：俺也一样啊）。7.1 节给出了一些更好的解释。



## 创建子程序的正当理由

- 管理复杂度，隐藏信息，缩小规模等。当内部循环或条件判断的嵌套层次很深时，就意味着需要从子程序中提取新的子程序了。提取嵌套部分，以降低外围子程序的复杂度。
- 引入中间、易懂的抽象。把一段代码放入一个命名恰当的子程序内，是说明这段代码用意的最好方式。且看下面一段代码：

```cpp
if (node != NULL) then
   while (node.next != NULL) do
      node = node.next
      leafName = node.name
   end while
else
   leafName = ""
end if
```
事实上，给它起一个好的名字就足以说明其用意：`leafName = GetLeafName(node)`
- 避免代码重复。如果在两段子程序内编写相似的代码，就意味着代码分解出了差错。
- 支持子类化。（注：咦，这是什么意思？）
- 隐藏顺序，把处理数据的顺序隐藏起来。（注：将相关操作“封装”起来，如 `popStack` 包括弹栈和减少计数值两个操作）
- 隐藏指针操作。指针操作的可读性往往都很差，且容易出错，必要时可考虑将其隔离起来。
- 提高可移植性。将使用子程序将不可移植的部分隔离起来，从而明确识别和隔离未来的移植工作。
- 简化复杂的布尔判断。一个好的函数名字便足以说明一行复杂布尔逻辑式的用意。
- 改善性能。便于对程序进行优化。
- 确保子程序都很小？ No，No，No……不是的，Steve 老师认为，“既然有这么多好的理由来把代码写成子程序，这一点就没有必要了。” 



## 观点：似乎过于简单的操作就没必要写成子程序？

编写有效的子程序时，一个最大的心理障碍就是：不情愿为一个简单的目的而编写一个简单的子程序。比如一个两三行的子程序看起来有点大材小用。但是有时，事情看起来发生了一些变化。比如这一行代码：
`points = deviceUnits * (POINTS_PER_INCH / DeviceUnitsPerInch());`

其实，如果把它放进子程序里，再起一个好的名字，代码就可以变得更加清晰：
`points = DeviceUnitsToPoints(deviceUnits);`

更多地，考虑下面两种情况：
- 如果上述代码需要在多处出现呢？
- 简单操作常常也会变成复杂操作，如果上述操作代码需要扩展呢？当避免“除零错误”时，就需要增加3行代码检查`DeviceUnitsPerInch()` 的返回值。（注：那么问题来了，事先怎么知道那行代码会不会多次出现，会不会有所扩展呢？）

除此之外，创建类的很多理由也正是创建子程序的原因。



## 内聚性：在子程序层上设计

内聚性是指子程序中各操作之间的紧密程度。强调这一概念的原因在于得到更高的可靠性。（注：7.2节列举了一些有关内聚性和程序错误数量相关性的研究，让人好奇的是，这些研究过程是怎样的）

“理解一些概念比记住一些特定术语更重要”，关于内聚性的讨论一般会涉及到内聚性的几个层次：
- 功能的内聚性。最强也是最好的一种内聚性，即让子程序仅执行一项操作，如 `sin()，EraseFile()` 等。以这种方式评价内聚性的前提是子程序执行的操作和名字相符合。除此之外，一些其他的内聚性通常不太理想。
- 顺序的内聚性。子程序内包含了有需要按特定顺序执行的操作恰，后一个操作需要依赖前一个操作的结果。改进方式：将操作写成子程序，后一个操作（函数）调用前一个操作（函数）来完成功能。
- 通信上的内聚性。子程序中的不同操作使用了同样的数据，但不存在其他联系。改进方式：将操作分别写进子程序，在原具有通信内聚性的子程序的更高层程序中调用新创建的子程序。
- 临时的内聚性。指含有一些因为需要同时执行才放到一起的操作的子程序。改进方式：让原来具有临时内聚性的子程序调用其他子程序来完成特定操作，而不是它直接执行所有操作。这里提示的另外一个问题是：如何选择一个能够在恰当的抽象层次上描述子程序的名字。

此外，还有一些不可取的内聚性：
- 过程上的内聚性。子程序中的操作是按特定的顺序进行的。
- 逻辑上的内聚性。若干操作被放入同一个子程序中，通过传入的控制标志选择执行其中的一项操作，但各项操作之间没有关联。似乎，这更应该称之为“缺乏逻辑的内聚性”。此外，当子程序为“事件处理器”时，这便不是什么问题。（注：具体情况具体分析）
- 巧合的内聚性。各个操作之间没有任何可以看到的关联，或者说“无内聚性”或“混乱的内聚性”。

这些规则都不是神圣不可侵犯的，需要理解其想法并根据实际情况运用。幸运的是，编写功能上的内聚性的子程序几乎都是可能的，因此应该把注意力集中在功能内聚性上，从而得到最大的收获（注：7.2节列举了很多精彩的例子以阐述各种内聚性的含义）。



## 好的子程序的名字

子程序命名的指导原则：
- 描述子程序所做的所有事情。
- 避免使用无意义的、模糊或表述不清的动词。如 `handle，deal` 等。
- 不要仅通过数字来形成不同的子程序的名字。
- 根据需要确定子程序名字的长度。研究表明，变量名的最佳长度是9到15个字符，子程序通常比变量更复杂。（注：不知道这是咋研究出来的）
- 给函数命名时要对返回值有所描述。
- 给过程起名时，使用语气强烈的动词加宾语的形式。
- 准确使用对仗词。以保持一致性，提高可读性。如：

| 1              | 2                   |           3 |
| -------------- | ------------------- | ----------: |
| add/remove     | increment/decrement |  open/close |
| begin/end      | insert/delete       |   show/hide |
| create/destroy | first/last          | lock/unlock |
| source/target  | min/max             |  start/stop |
| get/put        | next/previous       |     up/down |
| get/set        | old/new             |             |



## 子程序可以写多长？

7.4 节列举了很多子程序长度与错误量关系的研究（注：其中的部分结论貌似相互矛盾）。Steve老师的总结是：与其对子程序的长度强加限制，不如让下面的因素来决定子程序的长度。这些因素包括：子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、用以解释子程序所需的注释数量，以及其他一些跟复杂度相关的考虑事项等。

另外：对于超过200行代码的子程序来说，没有哪项研究发现它能降低成本或降低出错率，且在超过200行后，迟早会在程序的可读性方面遇到问题。（注：子程序超过200行时要特别注意才对）



## 如何使用子程序参数

子程序之间的接口是程序中最容易出错的部分之一，以下是减少接口错误的一些指导原则：
- 按照 `输入- 修改 - 输出` 的顺序排列参数。（注：这和C函数库中所用的把会被修改的参数排在最前面的规则不同）
- 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致。
- 使用所有的参数。
- 把状态或出错的变量放在最后。
- 不要把子程序的参数用做工作变量。这很危险！！！应将输入值赋值给工作变量再进行操作。
- 在接口中对参数的假定加以说明。如果假定了参数具有某种特征，就应对这种参数加以说明（在子程序内部和子程序的调用处）。不要等到把子程序写完之后再回过头去写注释（注：很容易忘记啊），一种比注释更好的办法是使用断言。

那么问题来了，应该对哪些假定进行说明呢？
1. 参数是仅用于输入的、要被修改的、还是仅用于输出的。
2. 表示数量的参数的单位 ，英寸、英尺、米等。
3. 如果没有枚举类型，应说明状态代码和错误值的含义。
4. 所能接受的数值范围。
5. 不该出现的特定数值等。

- 把子程序参数个数控制在7个以内。如果发现自己一直需要传递很多参数，这就说明子程序之间耦合太紧密了。如果向很多不同的子程序传递相同的数据，就应该考虑把这些子程序组成一个类，并把那些经常使用的数据用作类的内部数据。
- 考虑对参数采用某种表示输入、修改和输出的命名规则，如果认为把输入、修改和输出参数区分开很重要的话。
- 为子程序传递用以维持其接口抽象的变量或对象。如果发现自己经常需要修改子程序的参数表，而每次修改的参数都是来自于同一个对象，那就说明应该传递整个对象而不是个别数据项了。
- 使用具名参数。
- 确保实际参数与形式参数相匹配。养成好的习惯：总要检查参数表中的参数类型，同时留意编译器给出的关于参数类型不匹配的警告。



## 使用函数时的特别考虑

过程与函数：函数是指有返回值的子程序，过程是指没有返回值的子程序。两者更多的是语义的区别而非语法的差别。

什么时候使用过程，什么时候使用函数？如果一个子程序的主要用途就是返回由其名字所指明的返回值，那么就应该使用函数，否则就应该使用过程。

设置函数的返回值：使用函数时总存在返回不正确返回值的风险，下面是两条基本原则：
- 检查所有可能的返回路径。确保所有情况下该函数都会返回值。另外，在函数开头用一个默认值来初始化返回值是个很好的做法。
- 不要返回指向局部数据的引用或指针。

